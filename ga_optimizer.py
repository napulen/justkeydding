import string
import random
import subprocess

def generate_key_profile(maximum_range):
    ''' Generate a set of random key profiles '''
    major = generate_major_key_profile(maximum_range)
    minor = generate_minor_key_profile(maximum_range)
    return major + minor

def generate_major_key_profile(maximum_range):
    key_profile = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    ]
    tonic_dominant = [0, 7]
    diatonic = [2, 4, 5, 9, 11]
    non_diatonic = [1, 3, 6, 8, 10]
    groups = [
        (tonic_dominant, 0),
        (diatonic, 1),
        (non_diatonic, 2)
    ]
    for group, hierarchy in groups:
        for idx in group:
            r = random.randrange(int(maximum_range / 2**hierarchy))
            key_profile[idx] = r
    s = sum(key_profile)
    return [x/s for x in key_profile]

def generate_minor_key_profile(maximum_range):
    key_profile = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    ]
    tonic_dominant = [0, 7]
    harmonic = [2, 3, 5, 8, 11]
    natural_melodic = [4, 9, 10]
    non_diatonic = [1, 6]
    groups = [
        (tonic_dominant, 0),
        (harmonic, 1),
        (natural_melodic, 2),
        (non_diatonic, 3)
    ]
    for group, hierarchy in groups:
        for idx in group:
            r = random.randrange(int(maximum_range / 2**hierarchy))
            key_profile[idx] = r
    s = sum(key_profile)
    return [x/s for x in key_profile]

def generate_population(count, maximum_range):
    ''' Generate <count> key_profiles for a population '''
    return [generate_key_profile(maximum_range) for x in range(count)]

def grade(population):
    ''' Grade a whole population '''
    # summed = reduce(lambda x,y:x+y, (fitness(x, target) for x in pop), 0)
    # return summed / float(len(pop))
    grading = [(evaluate(x), x) for x in population]
    grading = sorted(grading, key=lambda score: score[0])
    return grading

def evaluate(key_profile):
    ''' Evaluate a key profile '''
    kp_string = ''
    for p in key_profile:
        kp_string = kp_string + '{:.12f} '.format(p)
    kp_string = kp_string[:-1]
    total_error = 0
    with open("midi_dataset.txt", "r") as f:
        for filename in f.readlines():
            filename = filename.strip()
            print(filename)
            justkeydding = subprocess.Popen(
                ('bin/justkeydding',
                '-e',
                '-K',
                '{}'.format(kp_string),
                filename),
                stdout=subprocess.PIPE)
            output, _ = justkeydding.communicate()
            try:
                score = float(output)
            except ValueError:
                score = 0.0
            error = 1 - score
            total_error += error
    return total_error

def evolve(population, maximum_range, retain=0.5,
    crossover=0.3, mutation_prob=0.1, mutation_ratio=0.1):
    ''' Evolver, assumes a population sorted by best performance first '''
    # Number of key profiles from the old population that we are keeping
    retain_length = int(len(population) * retain)
    # Number of key profiles that will be generated by mixing
    # the major and minor key profiles of 2 different samples
    crossover_length = int(len(population) * crossover)

    # Initialize the parents of the new population
    new_population = population[:retain_length]

    # Crossover parents to fill some of the population
    children = []
    while len(children) < crossover_length:
        male = random.choice(new_population)
        female = random.choice(new_population)
        if male != female:
            # Child is made of the major key of
            # the male and minor key of the female
            child = male[:12] + female[12:]
            children.append(child)
    new_population.extend(children)

    # Do some mutations. Mutations consist in giving a 'fraction'
    # of the magnitude of a pitch class and give it to another pitch class
    # The fraction is defined by 'mutation_ratio', default is 10%
    for kp in new_population:
        if mutation_prob > random.random():
            pc1_index = 0
            pc2_index = 0
            mode = random.choice(['major', 'minor'])
            mode_index = 0 if mode == 'major' else 12
            while pc1_index == pc2_index:
                pc1_index = random.randint(0, 11)
                pc2_index = random.randint(0, 11)
            pc1_index += mode_index
            pc2_index += mode_index
            delta = kp[pc1_index] * mutation_ratio
            kp[pc1_index] -= delta
            kp[pc2_index] += delta

    # Fill the rest of the population with random key profiles
    while len(population) > len(new_population):
        kp = generate_key_profile(maximum_range)
        new_population.append(kp)

    return new_population

# The program starts running here!
# main() is a function, and this if statement will call to that function
if __name__ == '__main__':
    population_size = 5
    maximum_range = 100
    population = generate_population(population_size, maximum_range)
    grading = grade(population)
    print(grading)
    best_performance, best_performer = grading[0]
    generation = 0
    if best_performance == 0:
        # First shot!
        print(best_performer)
    else:
        population = [x[1] for x in grading]
        while best_performance > 0:
            print('Generation {}'.format(generation))
            population = evolve(population, maximum_range)
            grading = grade(population)
            print(grading)
            best_performance, best_performer = grading[0]

