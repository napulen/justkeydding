import random
import logging
import copy
from . import key_profiles

class Evolver:
    def __init__(self, generator):
        self.logger = logging.getLogger('evolver')
        self.generator = generator
        self.logger.info('Evolver() <- generator={}'.format(generator))

    def evolve(self, population, retain=0.2, random_retain=0.2, crossover=0.3,
            mutation_prob=0.2, mutation_ratio=0.2):
        ''' Evolver, assumes a population sorted by best performance first '''
        self.logger.info('Start evolve() <- population={}, retain={}, random_retain={}, crossover={}, mutation_prob={}, mutation_ratio={}'.format(population, retain, random_retain, crossover, mutation_prob, mutation_ratio))
        # Number of key profiles from the old population that we are keeping
        retain_length = int(len(population) * retain)
        self.logger.debug('retain_length:{}'.format(retain_length))
        # Other random key profiles from the population that we are keeping
        random_retain_length = int(len(population) * random_retain)
        self.logger.debug('random_retain_length:{}'.format(random_retain_length))
        # Number of key profiles that will be generated by mixing
        # the major and minor key profiles of 2 different samples
        crossover_length = int(len(population) * crossover)
        self.logger.debug('crossover_length:{}'.format(crossover_length))

        # Initialize the parents of the new population
        new_population = copy.deepcopy(population[:retain_length])

        # Select random key profiles from the previous generation
        random_old = []
        while len(random_old) < random_retain_length:
            kp = random.choice(population[retain_length:])
            if kp not in random_old and kp not in new_population:
                self.logger.debug('random_kp_retained:{}'.format(kp))
                random_old.append(copy.deepcopy(kp))
        new_population.extend(random_old)

        # Crossover parents to fill some of the population
        children = []
        while len(children) < crossover_length:
            male_name = random.choice(new_population)
            female_name = random.choice(new_population)
            if male_name != female_name:
                # Child is made of the major key of
                # the male and minor key of the female
                child_name = '({},{})'.format(male_name, female_name)
                male_kp = key_profiles.get(male_name)
                female_kp = key_profiles.get(female_name)
                child_kp = male_kp[:12] + female_kp[12:]
                self.logger.debug('child:{}'.format(child_name))
                key_profiles.insert_new(child_name, child_kp)
                children.append(child_name)
        new_population.extend(children)

        # Do some mutations. Mutations consist in giving a 'fraction'
        # of the magnitude of a pitch class and give it to another pitch class
        # The fraction is defined by 'mutation_ratio', default is 10%
        for idx, key_profile_name in enumerate(new_population):
            if mutation_prob > random.random():
                mutation_name = '{}*'.format(key_profile_name)
                self.logger.debug('mutation:{}'.format(mutation_name))
                kp = copy.deepcopy(key_profiles.get(key_profile_name))
                index_range = random.choice([(0, 11), (12, 23)])
                pc1_index = 0
                pc2_index = 0
                while pc1_index == pc2_index:
                    pc1_index = random.randint(index_range[0], index_range[1])
                    pc2_index = random.randint(index_range[0], index_range[1])
                delta = kp[pc1_index] * mutation_ratio
                self.logger.debug('pc1 {} changes by {}, from {} to {}'.format(pc1_index, delta, kp[pc1_index], kp[pc1_index] - delta))
                self.logger.debug('pc2 {} changes by {}, from {} to {}'.format(pc2_index, delta, kp[pc2_index], kp[pc2_index] + delta))
                kp[pc1_index] -= delta
                kp[pc2_index] += delta
                key_profiles.insert_new(mutation_name, kp)
                new_population[idx] = mutation_name

        # Fill the rest of the population with random key profiles
        while len(population) > len(new_population):
            kp_name = self.generator.generate_key_profile()
            self.logger.debug('Generated key_profile: {}'.format(kp_name))
            new_population.append(kp_name)
        self.logger.info('Done evolve() -> new_population={}'.format(new_population))
        return new_population

