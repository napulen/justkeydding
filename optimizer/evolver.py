import random
import logging
import copy
logger = logging.getLogger(__name__)

class Evolver:
    def __init__(self, generator):
        self.logger = logging.getLogger('evolver')
        self.generator = generator
        self.logger.info('Evolver() <- generator={}'.format(generator))

    def evolve(self, population, retain=0.2, random_retain=0.2, crossover=0.3,
            mutation_prob=0.2, mutation_ratio=0.2):
        ''' Evolver, assumes a population sorted by best performance first '''
        self.logger.info('Start evolve() <- population={}, retain={}, random_retain={}, crossover={}, mutation_prob={}, mutation_ratio={}'.format(population, retain, random_retain, crossover, mutation_prob, mutation_ratio))
        # Number of key profiles from the old population that we are keeping
        retain_length = int(len(population) * retain)
        self.logger.debug('retain_length:{}'.format(retain_length))
        # Other random key profiles from the population that we are keeping
        random_retain_length = int(len(population) * random_retain)
        self.logger.debug('random_retain_length:{}'.format(random_retain_length))
        # Number of key profiles that will be generated by mixing
        # the major and minor key profiles of 2 different samples
        crossover_length = int(len(population) * crossover)
        self.logger.debug('crossover_length:{}'.format(crossover_length))

        # Initialize the parents of the new population
        new_population = copy.deepcopy(population[:retain_length])

        # Select random key profiles from the previous generation
        random_old = []
        while len(random_old) < random_retain_length:
            kp = random.choice(population[retain_length:])
            if kp not in random_old and kp not in new_population:
                self.logger.debug('random_kp_retained:{}'.format(kp))
                random_old.append(copy.deepcopy(kp))
        new_population.extend(random_old)

        # Crossover parents to fill some of the population
        children = []
        while len(children) < crossover_length:
            male = random.choice(new_population)
            female = random.choice(new_population)
            if male != female:
                # Child is made of the major key of
                # the male and minor key of the female
                child = male[:12] + female[12:]
                self.logger.debug('child:{}'.format(child))
                children.append(child)
        new_population.extend(children)

        # Do some mutations. Mutations consist in giving a 'fraction'
        # of the magnitude of a pitch class and give it to another pitch class
        # The fraction is defined by 'mutation_ratio', default is 10%
        for kp in new_population:
            if mutation_prob > random.random():
                pc1_index = 0
                pc2_index = 0
                mode = random.choice(['major', 'minor'])
                mode_index = 0 if mode == 'major' else 12
                while pc1_index == pc2_index:
                    pc1_index = random.randint(0, 11)
                    pc2_index = random.randint(0, 11)
                pc1_index += mode_index
                pc2_index += mode_index
                delta = kp[pc1_index] * mutation_ratio
                self.logger.debug('pc1 {} changes by {}, from {} to {}'.format(pc1_index, delta, kp[pc1_index], kp[pc1_index] - delta))
                self.logger.debug('pc2 {} changes by {}, from {} to {}'.format(pc2_index, delta, kp[pc2_index], kp[pc2_index] + delta))
                kp[pc1_index] -= delta
                kp[pc2_index] += delta

        # Fill the rest of the population with random key profiles
        while len(population) > len(new_population):
            kp = self.generator.generate_key_profile()
            self.logger.debug('Generated key_profile: {}'.format(kp))
            new_population.append(kp)
        self.logger.info('Done evolve() -> new_population={}'.format(new_population))
        return new_population

